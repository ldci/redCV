Extended Matrix! datatype

Toomas Vooglaid and Fran√ßois Jouen for Qingtian Xie

Matrix! supports char!, integer! and float! datatypes with different bit-sizes. 
Char! values are stored as unsigned 8 bits values.
For integer! values, you can store them as 8, 16 or 32 bits values. 
For float!, it is 32 or 64 bits. 

Several syntactic forms should be supported for creating a matrix:
make matrix! <dimension>
make vector! [<dimension> <values>]
make vector! [<type> <bit-size> <dimensions> [<values>]]
<dimension>    	: size of the matrix as pair! (columns x rows)
<data>   		: sequence of values of same datatype
<type>     		: name of accepted datatype: char! | integer!  | float! (actually an integer value [ 1 2 3]
<bit-size> 		: 8 for char! 
				  8| 16 | 32 for integer! 
				  32 | 64 for float!
				  
The type of the matrix elements should be inferred from the provided values, so it can be omitted (unless you need to force a bit-size different from the values default one). If a value with a bit-size greater than the vector elements one, is inserted in the vector, it must be truncated to the bit-size of the matrix.


For example, creating a 3 x 3 matrix that contains 9 32-bit integer values:
	make matrix! 3x3 
	== matrix! [integer! 32 3x3 0 0 0 0 0 0 0 0 0]
Or if you want to specify the bit-size of the matrix element: 
    make matrix! [char! 8 3x3]
    == matrix! [char! 8 3x3 #"^@" #"^@" #"^@" #"^@" #"^@" #"^@" #"^@" #"^@" #"^@"]
    make matrix! [integer! 32 3x3]
    == matrix! [integer! 32 3x3 0 0 0 0 0 0 0 0 0]
    make matrix! [float! 64 3x3]
    == matrix! [float! 32 3x3 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0]
You could also initialize a matrix with a block as below: 
	make matrix! [2x2 [1.1 2.2 3.3 4.4]]
	== matrix! [float! 64 2x2 1.1 2.2 3.3 4.4]
    make matrix! [float! 32 2x2 [1.1 2.2 3.3 4.4]]
    == matrix! [float! 32 2x2 1.1 2.2 3.3 4.4]

Basically matrix! datatype is close to vector! datatype, and thus must share basic actions for vector! datatype.
init: does [
		datatype/register [
			TYPE_VECTOR
			TYPE_STRING
			"vector!"
			;-- General actions --
			:make
			INHERIT_ACTION	;random
			INHERIT_ACTION	;reflect
			null			;to
			:form
			:mold
			INHERIT_ACTION	;eval-path
			null			;set-path
			:compare
			;-- Scalar actions --
			null			;absolute
			:add
			:divide
			:multiply
			null			;negate
			null			;power
			:remainder
			null			;round
			:subtract
			null			;even?
			null			;odd?
			;-- Bitwise actions --
			:and~
			null			;complement
			:or~
			:xor~
			;-- Series actions --
			null			;append
			INHERIT_ACTION	;at
			INHERIT_ACTION	;back
			INHERIT_ACTION	;change
			INHERIT_ACTION	;clear
			INHERIT_ACTION	;copy
			INHERIT_ACTION	;find
			INHERIT_ACTION	;head
			INHERIT_ACTION	;head?
			INHERIT_ACTION	;index?
			:insert
			INHERIT_ACTION	;length?
			INHERIT_ACTION	;move
			INHERIT_ACTION	;next
			INHERIT_ACTION	;pick
			INHERIT_ACTION	;poke
			null			;put
			INHERIT_ACTION	;remove
			INHERIT_ACTION	;reverse
			INHERIT_ACTION	;select
			INHERIT_ACTION	;sort
			INHERIT_ACTION	;skip
			null			;swap
			INHERIT_ACTION	;tail
			INHERIT_ACTION	;tail?
			INHERIT_ACTION	;take
			null			;trim
			;-- I/O actions --
			null			;create
			null			;close
			null			;delete
			INHERIT_ACTION	;modify
			null			;open
			null			;open?
			null			;query
			null			;read
			null			;rename
			null			;update
			null			;write
		]
	]

However, matrices are a little bit more complicated than vector. 
For example, matrice product is not a term to term multiplication but a dot product. The same problem for division. We also need to support >>, >>> and << bit-wise operators and so on.


