Red [	Title:   "Red Computer Vision: Image Processing"	Author:  "Francois Jouen"	File: 	 %rcvImgProc.red	Tabs:	 4	Rights:  "Copyright (C) 2016 Francois Jouen. All rights reserved."	License: {		Distributed under the Boost Software License, Version 1.0.		See https://github.com/red/red/blob/master/BSL-License.txt	}]#include %rcvImgProcRoutines.red; ************ Color space conversions **********; To be implemented or not?; rcvColor src dst code rcvRGB2XYZ: function [src [image!] dst [image!]"RGB to CIE XYZ color conversion"] [	_rcvXYZ src dst 1] rcvBGR2XYZ: function [src [image!] dst [image!]"BGR to CIE XYZ color conversion"] [	_rcvXYZ src dst 2] rcvXYZ2RGB: function [src [image!] dst [image!]"CIE XYZ to RBG color conversion"] [	_rcvXYZRGB src dst] rcvRGB2HSV: function [src [image!] dst [image!]"RBG color to HSV conversion"] [	_rcvHSV src dst 1] rcvBGR2HSV: function [src [image!] dst [image!]"BGR color to HSV conversion"] [	_rcvHSV src dst 2] rcvRGB2YCrCb: function [src [image!] dst [image!]"RBG color to YCrCb conversion"] [	_rcvYCrCb src dst 1] rcvBGR2YCrCb: function [src [image!] dst [image!]"BGR color to YCrCb conversion"] [	_rcvYCrCb src dst 2]rcvRGB2HLS: function [src [image!] dst [image!]"RBG color to HLS conversion"] [	_rcvHLS src dst 1] rcvBGR2HLS: function [src [image!] dst [image!]"BGR color to HLS conversion"] [	_rcvHLS src dst 2]rcvRGB2Lab: function [src [image!] dst [image!]"RBG color to CIE L*a*b conversion"] [	_rcvLab src dst 1] rcvBGR2Lab: function [src [image!] dst [image!]"BGR color to CIE L*a*b conversion"] [	_rcvLab src dst 2]rcvRGB2Luv: function [src [image!] dst [image!]"RBG color to CIE L*u*v conversion"] [	_rcvLuv src dst 1] rcvBGR2Luv: function [src [image!] dst [image!]"BGR color to CIE L*u*v conversion"] [	_rcvLuv src dst 2]; ************ image transform **********rcvFlip: function [src [image!] dst [image!] /horizontal /vertical /both return: [image!]"Left Right, Up down or both directions flip"][	case [		horizontal 	[_rcvFlipHV src dst 1]		vertical 	[_rcvFlipHV src dst 2]		both		[_rcvFlipHV src dst 3]	]	]; ********* Image Convolution **********{The 2D convolution operation isn't extremely fast, unless you use small filters. We'll usually be using 3x3 or 5x5 filters. There are a few rules about the filter:Its size has to be uneven, so that it has a center, for example 3x3, 5x5, 7x7 or 9x9 are ok. Apart from using a kernel matrix, convolution operation also has a multiplier factor and a bias. After applying the filter, the factor will be multiplied with the result, and the bias added to it. So if you have a filter with an element 0.25 in it, but the factor is set to 2, all elements of the filter are  multiplied by two so that element 0.25 is actually 0.5. The bias can be used if you want to make the resulting image brighter. }rcvConvolve: function [src [image!] dst [image!] kernel [block!] factor [float!] delta [float!]"Convolves an image with the kernel"] [	_rcvConvolve src dst kernel factor delta]rcvFastConvolve: function [src [image!] dst [image!] channel [integer!] kernel [block!] factor [float!] delta [float!]"Convolves a 8-bit and 1-channel image with the kernel"] [	_rcvFastConvolve src dst channel kernel factor delta]rcvFilter2D: function [src [image!] dst [image!] kernel [block!]  delta [integer!]"Basic convolution Filter"] [	_rcvFilter2D src dst kernel delta]	rcvFastFilter2D: function [src [image!] dst [image!] kernel [block!]"Faster convolution Filter"] [	_rcvFastFilter2D src dst kernel]rcvMakeGaussian: function [kSize [pair!] return: [block!]"Creates a gaussian uneven kernel"][  gaussian: copy []  n: kSize/x - 1 / 2  i: negate n  j: negate n    sum: 0.0  stdv: 1.0  r: s: 2.0 * (stdv * stdv)  while [j <= n] [  	while [i <= n] [  		r: square-root (i * i) + (j * j)  		append gaussian exp  ((negate(r * r) / s) / (pi * s))  		sum: sum + exp  ((negate(r * r) / s) / (pi * s))  		i: i + 1  	]  	i: negate n  	j: j + 1  ]  ; now normalize the kernel  i: 0  while [i < (kSize/x * kSize/y)] [  	gaussian/(i + 1): gaussian/(i + 1) / sum  	i: i + 1  ]   gaussian	]rcvGaussianFilter: function [src [image!] dst [image!]"Gaussian 2D Filter"] [	kernel: rcvMakeGaussian 3x3	_rcvFilter2D src dst kernel 0]rcvSobel: function [src [image! vector!]  dst [image! vector!] iSize [pair!]"Direct Sobel Edges Detection"] [	t: type? src	if t = vector! [_rcvSobelMat src dst iSize]	if t = image! [			img1: rcvCreateImage iSize			img2: rcvCreateImage iSize			rcvConvolve src img1 [1.0 2.0 1.0 0.0 0.0 0.0 -1.0 -2.0 -1.0] 1.0 0.0			rcvConvolve src img2 [1.0 2.0 -1.0 2.0 0.0 -2.0 1.0 -2.0 -1.0] 1.0 0.0			rcvAdd img1 img2 dst			rcvReleaseImage img1			rcvReleaseImage img2	]]rcvRobert: function [src [image! vector!] dst [image! vector!] iSize [pair!] factor [float!] delta [float!]"Robert's Cross Edges Detection"] [	t: type? src	if t = vector! [			; pbs TBT			mat1: rcvCreateMat 'integer! 8 iSize			mat2: rcvCreateMat 'integer! 8 iSize			_rcvConvolveMat src mat1 iSize [0.0 1.0 -1.0 0.0] factor delta			_rcvConvolveMat src mat2 iSize [1.0 0.0 0.0 -1.0] factor delta			dst: mat1 + mat2			rcvReleaseMat mat1			rcvReleaseMat mat2			]	if t = image! [			img1: rcvCreateImage iSize			img2: rcvCreateImage iSize			_rcvConvolve src img1 [0.0 1.0 -1.0 0.0] factor delta			_rcvConvolve src img2 [1.0 0.0 0.0 -1.0] factor delta			rcvAdd img1 img2 dst			rcvReleaseImage img1			rcvReleaseImage img2	]];******************* Image Transformations *****************************rcvResizeImage: function [src [image!] canvas iSize [pair!]/Gaussian return: [pair!]"Resizes image and applies filter for Gaussian pyramidal resizing if required"][	tmpImg: rcvCloneImage src	case [		gaussian [			knl: rcvMakeGaussian 5x5			_rcvFilter2D tmpImg src knl 0		]	]	rcvReleaseImage tmpImg	canvas/size: iSize	src: to-image canvas	src/size]rcvScaleImage: function [factor [float!] return: [block!]"Returns a Draw block for image scaling"][	compose [scale (factor) (factor) image]]rcvRotateImage: function [scaleValue [float!] translateValue [pair!] angle [float!] center [pair!] return: [block!]"Returns a Draw block for image rotation"][	compose [scale (scaleValue) (scaleValue) translate (translateValue) rotate (angle) (center) image]]rcvTranslateImage: function [scaleValue [float!] translateValue [pair!] return: [block!]"Returns a Draw block for image translation"][	compose [scale (scaleValue) (scaleValue) translate (translateValue) image]]rcvSkewImage: function [scaleValue [float!] translateValue [pair!] x [number!] y [number!] return: [block!]"Returns a Draw block for image transformation"][	compose [scale (scaleValue) (scaleValue) translate (translateValue) skew (x) (y) image]]; morphological operatorsrcvCreateStructuringElement: function [kSize [pair!] return: [block!] /rectangle /cross"The function  allocates and fills a block, which can be used as a structuring element in the morphological operations"][	element: copy []	cols: kSize/x	rows: kSize/y  	i: 1  	j: 1  	case [  		rectangle [  			i: j: 1  			while [j <= rows] [  				while [i <= cols] [  					append element 1   					i: i + 1  				]  				i: 1  				j: j + 1  			]  		]  		cross [  			i: j: 1  			while [i <= (rows * cols)] [append element 0 i: i + 1]  			cx: cols / 2   			cy: rows / 2   			i: 0  			j: 0  			while [j < rows] [  				while [i < cols] [  					idx: (j * cols) + i + 1  					if (i = cx) [element/(idx): 1]  					if (j = cy) [element/(idx): 1]  					i: i + 1  				]  				i: 0  				j: j + 1  			]  		]  		  	]  	element]rcvErode: function [ src [image!] dst [image!] kSize [pair!] shape [integer!]"Erodes image by using arbitrary structuring element"] [	switch shape [		1	[se: rcvCreateStructuringElement/cross ksize]		2	[se: rcvCreateStructuringElement/rectangle ksize]	]	_rcvErode src dst kSize/x kSize/y se]rcvDilate: function [ src [image!] dst [image!] kSize [pair!] shape [integer!]"Dilates image by using arbitrary structuring element"] [	switch shape [		1	[se: rcvCreateStructuringElement/cross ksize]		2	[se: rcvCreateStructuringElement/rectangle ksize]	]	_rcvDilate src dst kSize/x kSize/y se ]