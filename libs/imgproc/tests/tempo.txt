__rcvMorphology: routine [    src  	[image!]    dst  	[image!]    cols	[integer!]    rows	[integer!]    kernel 	[block!]     op		[integer!]    /local        pix1 	[int-ptr!]        pixD 	[int-ptr!]        idx	 	[int-ptr!]        idx2	[int-ptr!]        handle1 handleD h w x y i j                pixelr pixelg pixelb         k  imx imy imx2 imy2        r g b rn gn bn		kBase 		kValue  ][    handle1: 0    handleD: 0    pix1: image/acquire-buffer src :handle1    pixD: image/acquire-buffer dst :handleD    idx:  pix1    idx2: pix1    w: IMAGE_WIDTH(src/size)    h: IMAGE_HEIGHT(src/size)    ; get Kernel dimension (e.g. 3, 5 ...)	kBase: block/rs-head kernel ; get pointer address of the kernel first value    x: 0    y: 0    j: 0    i: 0        while [y < h] [    	while [x < w][    		; OK pixel (-n, -n) will correctly become pixel (w-n, h-n)    		imx:  (x + (cols / 2) + w ) % w         	imy:  (y + (rows / 2) + h ) % h        	idx: pix1 + (imy * w) + imx  ; corrected pixel index in image        	r: idx/value and 00FF0000h >> 16         	g: idx/value and FF00h >> 8        		b: idx/value and FFh         	; now read kernel and associated pixels in image         	kValue: kBase        	j: 0        	switch op [        				1 [ pixelr: 0 pixelg: 0 pixelb: 0]        				2 [ pixelr: 255 pixelg: 255 pixelb: 255]        	]        	        	while [j < rows][        		i: 0        		while [i < cols][        			imx2: imx + i - (cols / 2) % cols        			imy2: imy + j - (rows / 2) % rows        			idx2: pix1 + (imy2 * w) + imx2        			rn: idx2/value and 00FF0000h >> 16         			gn: idx2/value and FF00h >> 8        				bn: idx2/value and FFh         			k: as red-integer! kValue        			if k/value = 1 [        				switch op [        					1 [         						pixelr: pixelr AND rn        						pixelg: pixelg AND gn        						pixelb: pixelb AND bn        				  	] ; erosion        					2 [         						pixelr: pixelr OR rn        						pixelg: pixelg OR gn         						pixelb: pixelb OR bn        					] ; dilatation        				]        			]        			kValue: kBase + (j * cols + i + 1)        			i: i + 1        		]        		j: j + 1        	]        	                	either pixelr = r [r: 0] [r: 255]        	either pixelg = g [g: 0] [g: 255]        	either pixelb = b [b: 0] [b: 255]        	        	         	pixD/value: ((255 << 24) OR (r << 16 ) OR (g << 8) OR b)        	pixD: pixD + 1        	x: x + 1       ]       x: 0       y: y + 1    ]    image/release-buffer src handle1 no    image/release-buffer dst handleD yes]_rcvMorphology: routine [    src  	[image!]    dst  	[image!]    cols	[integer!]    rows	[integer!]    kernel 	[block!]     op		[integer!]    /local        pix1 	[int-ptr!]        pixD 	[int-ptr!]        idx	 	[int-ptr!]        idx2	[int-ptr!]        handle1 handleD h w x y i j                pixelr pixelg pixelb         minir maxir        minig maxig        minib maxib        k  imx imy imx2 imy2        r g b rn gn bn		kBase 		kValue  ][    handle1: 0    handleD: 0    pix1: image/acquire-buffer src :handle1    pixD: image/acquire-buffer dst :handleD    idx:  pix1    idx2: pix1    w: IMAGE_WIDTH(src/size)    h: IMAGE_HEIGHT(src/size)    ; get Kernel dimension (e.g. 3, 5 ...)	kBase: block/rs-head kernel ; get pointer address of the kernel first value    x: 0    y: 0    j: 0    i: 0    minir: 255    maxir: 0    minig: 255    maxig: 0    minib: 255    maxib: 0    while [y < h] [    	while [x < w][    		; OK pixel (-n, -n) will correctly become pixel (w-n, h-n)    		imx:  (x + (cols / 2) + w ) % w         	imy:  (y + (rows / 2) + h ) % h        	idx: pix1 + (imy * w) + imx  ; corrected pixel index in image        	r: idx/value and 00FF0000h >> 16         	g: idx/value and FF00h >> 8        		b: idx/value and FFh         	; now read kernel and associated pixels in image         	kValue: kBase        	j: 0        	while [j < rows][        		i: 0        		while [i < cols][        			imx2: imx + i - (cols / 2) % cols        			imy2: imy + j - (rows / 2) % rows        			idx2: pix1 + (imy2 * w) + imx2        			rn: idx2/value and 00FF0000h >> 16         			gn: idx2/value and FF00h >> 8        				bn: idx2/value and FFh         			k: as red-integer! kValue        			switch op [        				1 [ pixelr: r - (k/value * rn)        					pixelg: g - (k/value * gn)        					pixelb: b - (k/value * bn)        				  ] ; erosion        				2 [ pixelr: (k/value * rn) - r        					pixelg: (k/value * gn) - g        					pixelb: (k/value * bn) - b        				] ; dilatation        			]        			        			;if pixelr < 0 [pixelr: 0]        			;if pixelg < 0 [pixelg: 0]        			;if pixelb < 0 [pixelb: 0]        			        			        			if pixelr > maxir [maxir: pixelr]        			if pixelr < minir [minir: pixelr]         			if pixelg > maxig [maxig: pixelg]          			if pixelg < minig [minig: pixelg]          			if pixelb > maxib [maxib: pixelb]         			if pixelb < minib [minib: pixelb]        			        			kValue: kBase + (j * cols + i + 1)        			i: i + 1        		]        		j: j + 1        	]        	        	        	switch op [        				1	[r: r + minir g: g + minig b: b + minib] ; erosion        				2	[r: r + maxir g: g + maxig b: b + maxib]  ; dilatation        			]        	        	pixD/value: ((255 << 24) OR (r << 16 ) OR (g << 8) OR b)        	pixD: pixD + 1        	x: x + 1       ]       x: 0       y: y + 1    ]    image/release-buffer src handle1 no    image/release-buffer dst handleD yes]